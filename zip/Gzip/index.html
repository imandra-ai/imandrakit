<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Gzip (zip.Gzip)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">zip</a> &#x00BB; Gzip</nav><header class="odoc-preamble"><h1>Module <code><span>Gzip</span></code></h1><p>Reading and writing to/from <code>gzip</code> compressed files</p><p>This module provides functions to read and write compressed data to/from files in <code>gzip</code> format.</p></header><nav class="odoc-toc"><ul><li><a href="#reading-from-compressed-files">Reading from compressed files</a></li><li><a href="#writing-to-compressed-files">Writing to compressed files</a></li><li><a href="#error-reporting">Error reporting</a></li></ul></nav><div class="odoc-content"><h2 id="reading-from-compressed-files"><a href="#reading-from-compressed-files" class="anchor"></a>Reading from compressed files</h2><div class="odoc-spec"><div class="spec type anchored" id="type-in_channel"><a href="#type-in_channel" class="anchor"></a><code><span><span class="keyword">type</span> in_channel</span></code></div><div class="spec-doc"><p>Abstract type representing a channel opened for reading from a compressed file.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-open_in"><a href="#val-open_in" class="anchor"></a><code><span><span class="keyword">val</span> open_in : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-in_channel">in_channel</a></span></code></div><div class="spec-doc"><p>Abstract type representing a channel opened for reading from a compressed file.</p><p>Open a compressed file for reading. The argument is the file name.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-open_in_chan"><a href="#val-open_in_chan" class="anchor"></a><code><span><span class="keyword">val</span> open_in_chan : <span><a href="../../ocaml/Stdlib/index.html#type-in_channel">in_channel</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-in_channel">in_channel</a></span></code></div><div class="spec-doc"><p>Open a compressed file for reading. The argument is the file name.</p><p>Open a compressed file for reading. The argument is a regular file channel already opened on the compressed file.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-input_char"><a href="#val-input_char" class="anchor"></a><code><span><span class="keyword">val</span> input_char : <span><a href="#type-in_channel">in_channel</a> <span class="arrow">&#45;&gt;</span></span> char</span></code></div><div class="spec-doc"><p>Open a compressed file for reading. The argument is a regular file channel already opened on the compressed file.</p><p>Uncompress one character from the given channel, and return it. Raise <code>End_of_file</code> if no more compressed data is available.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-input_byte"><a href="#val-input_byte" class="anchor"></a><code><span><span class="keyword">val</span> input_byte : <span><a href="#type-in_channel">in_channel</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Uncompress one character from the given channel, and return it. Raise <code>End_of_file</code> if no more compressed data is available.</p><p>Same as <code>Gzip.input_char</code>, but return the 8-bit integer representing the character. Raise <code>End_of_file</code> if no more compressed data is available.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-input"><a href="#val-input" class="anchor"></a><code><span><span class="keyword">val</span> input : <span><a href="#type-in_channel">in_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Same as <code>Gzip.input_char</code>, but return the 8-bit integer representing the character. Raise <code>End_of_file</code> if no more compressed data is available.</p><p><code>input ic buf pos len</code> uncompresses up to <code>len</code> characters from the given channel <code>ic</code>, storing them in string <code>buf</code>, starting at character number <code>pos</code>. It returns the actual number of characters read, between 0 and <code>len</code> (inclusive). A return value of 0 means that the end of file was reached. A return value between 0 and <code>len</code> exclusive means that not all requested <code>len</code> characters were read, either because no more characters were available at that time, or because the implementation found it convenient to do a partial read; <code>input</code> must be called again to read the remaining characters, if desired. (See also <code>Gzip.really_input</code> for reading exactly <code>len</code> characters.) Exception <code>Invalid_argument &quot;Gzip.input&quot;</code> is raised if <code>pos</code> and <code>len</code> do not designate a valid substring of <code>buf</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-really_input"><a href="#val-really_input" class="anchor"></a><code><span><span class="keyword">val</span> really_input : <span><a href="#type-in_channel">in_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>input ic buf pos len</code> uncompresses up to <code>len</code> characters from the given channel <code>ic</code>, storing them in string <code>buf</code>, starting at character number <code>pos</code>. It returns the actual number of characters read, between 0 and <code>len</code> (inclusive). A return value of 0 means that the end of file was reached. A return value between 0 and <code>len</code> exclusive means that not all requested <code>len</code> characters were read, either because no more characters were available at that time, or because the implementation found it convenient to do a partial read; <code>input</code> must be called again to read the remaining characters, if desired. (See also <code>Gzip.really_input</code> for reading exactly <code>len</code> characters.) Exception <code>Invalid_argument &quot;Gzip.input&quot;</code> is raised if <code>pos</code> and <code>len</code> do not designate a valid substring of <code>buf</code>.</p><p><code>really_input ic buf pos len</code> uncompresses <code>len</code> characters from the given channel, storing them in string <code>buf</code>, starting at character number <code>pos</code>. Raise <code>End_of_file</code> if fewer than <code>len</code> characters can be read. Raise <code>Invalid_argument &quot;Gzip.input&quot;</code> if <code>pos</code> and <code>len</code> do not designate a valid substring of <code>buf</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-close_in"><a href="#val-close_in" class="anchor"></a><code><span><span class="keyword">val</span> close_in : <span><a href="#type-in_channel">in_channel</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>really_input ic buf pos len</code> uncompresses <code>len</code> characters from the given channel, storing them in string <code>buf</code>, starting at character number <code>pos</code>. Raise <code>End_of_file</code> if fewer than <code>len</code> characters can be read. Raise <code>Invalid_argument &quot;Gzip.input&quot;</code> if <code>pos</code> and <code>len</code> do not designate a valid substring of <code>buf</code>.</p><p>Close the given input channel. If the channel was created with <code>Gzip.open_in_chan</code>, the underlying regular file channel (of type <code>Stdlib.in_channel</code>) is also closed. Do not apply any of the functions above to a closed channel.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-dispose"><a href="#val-dispose" class="anchor"></a><code><span><span class="keyword">val</span> dispose : <span><a href="#type-in_channel">in_channel</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Close the given input channel. If the channel was created with <code>Gzip.open_in_chan</code>, the underlying regular file channel (of type <code>Stdlib.in_channel</code>) is also closed. Do not apply any of the functions above to a closed channel.</p><p>Same as <code>Gzip.close_in</code>, but does not close the underlying regular file channel (of type <code>Stdlib.in_channel</code>); just dispose of the resources associated with the decompression channel. This can be useful if e.g. the underlying file channel is a network socket on which more (uncompressed) data is expected.</p></div></div><h2 id="writing-to-compressed-files"><a href="#writing-to-compressed-files" class="anchor"></a>Writing to compressed files</h2><div class="odoc-spec"><div class="spec type anchored" id="type-out_channel"><a href="#type-out_channel" class="anchor"></a><code><span><span class="keyword">type</span> out_channel</span></code></div><div class="spec-doc"><p>Abstract type representing a channel opened for writing to a compressed file.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-open_out"><a href="#val-open_out" class="anchor"></a><code><span><span class="keyword">val</span> open_out : <span><span class="optlabel">?level</span>:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-out_channel">out_channel</a></span></code></div><div class="spec-doc"><p>Abstract type representing a channel opened for writing to a compressed file.</p><p>Open a compressed file for writing. The argument is the file name. The file is created if it does not exist, or truncated to zero length if it exists. The optional <code>level</code> argument (an integer between 1 and 9) indicates the compression level, with 1 being the weakest (but fastest) compression and 9 being the strongest (but slowest) compression. The default level is 6 (medium compression).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-open_out_chan"><a href="#val-open_out_chan" class="anchor"></a><code><span><span class="keyword">val</span> open_out_chan : <span><span class="optlabel">?level</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ocaml/Stdlib/index.html#type-out_channel">out_channel</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-out_channel">out_channel</a></span></code></div><div class="spec-doc"><p>Open a compressed file for writing. The argument is the file name. The file is created if it does not exist, or truncated to zero length if it exists. The optional <code>level</code> argument (an integer between 1 and 9) indicates the compression level, with 1 being the weakest (but fastest) compression and 9 being the strongest (but slowest) compression. The default level is 6 (medium compression).</p><p>Open a compressed file for writing. The argument is a regular file channel already opened on the compressed file. The optional <code>level</code> argument sets the compression level as documented for <code>Gzip.open_out</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-output_char"><a href="#val-output_char" class="anchor"></a><code><span><span class="keyword">val</span> output_char : <span><a href="#type-out_channel">out_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Open a compressed file for writing. The argument is a regular file channel already opened on the compressed file. The optional <code>level</code> argument sets the compression level as documented for <code>Gzip.open_out</code>.</p><p>Output one character to the given compressed channel.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-output_byte"><a href="#val-output_byte" class="anchor"></a><code><span><span class="keyword">val</span> output_byte : <span><a href="#type-out_channel">out_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Output one character to the given compressed channel.</p><p>Same as <code>Gzip.output_char</code>, but the output character is given by its code. The given integer is taken modulo 256.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-output"><a href="#val-output" class="anchor"></a><code><span><span class="keyword">val</span> output : <span><a href="#type-out_channel">out_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Same as <code>Gzip.output_char</code>, but the output character is given by its code. The given integer is taken modulo 256.</p><p><code>output oc buf pos len</code> compresses and writes <code>len</code> characters from string <code>buf</code>, starting at offset <code>pos</code>, and writes the compressed data to the channel <code>oc</code>. Raise <code>Invalid_argument &quot;Gzip.output&quot;</code> if <code>pos</code> and <code>len</code> do not designate a valid substring of <code>buf</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-output_substring"><a href="#val-output_substring" class="anchor"></a><code><span><span class="keyword">val</span> output_substring : <span><a href="#type-out_channel">out_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>output oc buf pos len</code> compresses and writes <code>len</code> characters from string <code>buf</code>, starting at offset <code>pos</code>, and writes the compressed data to the channel <code>oc</code>. Raise <code>Invalid_argument &quot;Gzip.output&quot;</code> if <code>pos</code> and <code>len</code> do not designate a valid substring of <code>buf</code>.</p><p>Same as <code>output</code>, but takes a string as argument instead of a byte sequence.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.06</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-close_out"><a href="#val-close_out" class="anchor"></a><code><span><span class="keyword">val</span> close_out : <span><a href="#type-out_channel">out_channel</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Same as <code>output</code>, but takes a string as argument instead of a byte sequence.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.06</li></ul><p>Close the given output channel. If the channel was created with <code>Gzip.open_out_chan</code>, the underlying regular file channel (of type <code>Stdlib.out_channel</code>) is also closed. Do not apply any of the functions above to a closed channel.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-flush"><a href="#val-flush" class="anchor"></a><code><span><span class="keyword">val</span> flush : <span><a href="#type-out_channel">out_channel</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Close the given output channel. If the channel was created with <code>Gzip.open_out_chan</code>, the underlying regular file channel (of type <code>Stdlib.out_channel</code>) is also closed. Do not apply any of the functions above to a closed channel.</p><p>Same as <code>Gzip.close_out</code>, but do not close the underlying regular file channel (of type <code>Stdlib.out_channel</code>); just flush all pending compressed data and dispose of the resources associated with the compression channel. This can be useful if e.g. the underlying file channel is a network socket on which more data is to be sent.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-flush_continue"><a href="#val-flush_continue" class="anchor"></a><code><span><span class="keyword">val</span> flush_continue : <span><a href="#type-out_channel">out_channel</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Same as <code>Gzip.close_out</code>, but do not close the underlying regular file channel (of type <code>Stdlib.out_channel</code>); just flush all pending compressed data and dispose of the resources associated with the compression channel. This can be useful if e.g. the underlying file channel is a network socket on which more data is to be sent.</p><p>Flush all pending compressed data through both the compression channel and the underlying regular file channel, but keep both channels open to accept further data.</p></div></div><h2 id="error-reporting"><a href="#error-reporting" class="anchor"></a>Error reporting</h2><div class="odoc-spec"><div class="spec exception anchored" id="exception-Error"><a href="#exception-Error" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Error</span> <span class="keyword">of</span> string</span></code></div><div class="spec-doc"><p>Exception raised by the functions above to signal errors during compression or decompression, or ill-formed input files.</p></div></div></div></body></html>
